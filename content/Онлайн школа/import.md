---
date: 2024-10-03
tags:
  - Онлайн-школа
---
Модуль предназначен для импорта данных.

## ImportController

UseGuards

- ThrottlerGuard
- JWTGuard
- SuperAdminRoleGuard)

### Endpoints

Контроллер предоставляет следующие эндпоинты:

| Метод | URL                                            | Описание                  |
| ----- | ---------------------------------------------- | ------------------------- |
| GET   | `api/widget/imports/users/`                    | Импорт пользователей      |
| GET   | `api/widget/imports/catalogs/`                 | Импорт каталогов          |
| GET   | `api/widget/imports/materials/`                | Импорт учебных материалов |
| GET   | `api/widget/imports/tests/`                    | Импорт тестов!!!          |
| GET   | `api/widget/imports/subjects/`                 | Импорт предметов          |
| GET   | `api/widget/imports/programs/`                 | Импорт программ           |
| GET   | `api/widget/imports/sections/`                 | Импорт разделов           |
| GET   | `api/widget/imports/seo/`                      |                           |
| GET   | `api/widget/imports/video/`                    |                           |
| GET   | `api/widget/imports/get-all-ids/:entity/`      |                           |
| POST  | `api/widget/imports/update-entities-slug/`     |                           |
| GET   | `api/widget/imports/update-sections-subjects/` |                           |
| GET   | `api/widget/imports/attempts-numbers/`         |                           |
| GET   | `api/widget/imports/set-lesson-sorts/`         |                           |

### Импорт пользователей

`GET api/widget/imports/users/`

*Входные данные:* Отсутствуют

*Функционал:*

Работа метода разделена на несколько этапов:

1. Получение данных пользователей, которые нужно импортировать: отправляет GET-запрос к URL `users/import`, который должен вернуть массив данных пользователей в формате, соответствующем типу OldUser:

```json
{
  id: number;
  createdAt?: string;
  updatedAt: string;
  tatus: string;
  profileUpdatedAt: string;
  lastSignIn: string;
  pwdHash: string;
  salt: string;
  firstName: string;
  lastName: string;
  email: string | null;
  phoneNumber: string | null;
  middleName: string;
}
```
   
2. Проверка какие пользователи уже существуют в базе данных, на основе ID полученных на предыдущем шаге
3. Получение роли по умолчанию, которая будет назначена новым пользователям (задана в коде сервиса `defaultRole = 'student'`). В случае если роль не найдена выбрасывается исключение InternalServerErrorException с сообщением об ошибке "The default role was not found"
4. Разделение полученного массива пользователей на создаваемых и обновляемых: `creatingUsers[]` и `updatingUsers[]`
5. Массивы `creatingUsers` и `updatingUsers` объединяются в массив `usersToSave`.
6. Определение количества пользователей для создания и обновления. Фильтрация пользователей с пустыми id.
7. Если в массиве `usersToSave` присутствуют пользователи, выполняет сохранение информации в базе данных. Перед началом выполнения операции и по окончании, в лог будет выведено сообщение с количеством создаваемых и обновляемых пользователей.

*Выходные данные:* Status: `200 OK`

Возвращает объект, содержащий количество созданных и обновленных пользователей, а также их идентификаторы.

```json
{
  created: {
    count: number;
    id: number[] | string[];
  };
  updated: {
    count: number;
    id: number[] | string[];
  };
}
```

### Импорт каталогов

`GET api/widget/imports/catalogs/`

*Входные данные:* Отсутствуют

*Функционал:*

Работа метода разделена на несколько этапов:

1. Получение данных пользователей, которые нужно импортировать: отправляет GET-запрос к URL `materials/catalogs/import`, который должен вернуть массив данных о каталогах в формате, соответствующем типу OldCatalog.
	1. При этом отфильтровываются результаты с не заданным параметром `catalog`
	2. Преобразовываются данные параметра `catalog` (путь каталога): двойные слеши `//` заменяются на `%2F/`, завершающий слеш `/` заменяется на `%2F`, последовательность из нескольких пробелов заменяется на один пробел.
	3. Выполняется поиск дубликатов

```json
{
  id: number;
  createdAt?: string;
  updatedAt: string;
  type: PROGRAM | MATERIAL;
  status: ACTIVE | ARCHIVE;
  catalog: string;
}
```

2. Проверка какие каталоги уже существуют в базе данных, на основе ID полученных на предыдущем шаге
3. Формируется древо каталогов с разделением по типу (программы, учебные материалы) и статусы (активный, архивный)
4. Создается массив каталогов `catalogsForSave`, который содержит каталоги, готовые к сохранению в базе данных. В этом массиве также учитываются каталоги, которые необходимо создать и обновить
5. если массив `catalogsForSave` не пуст, происходит сохранение новых и обновление существующих каталогов в базе данных. Логируется количество создаваемых и обновляемых каталогов, а также выполняется фактическое сохранение

*Выходные данные:* Status: `200 OK`

Возвращает объект, содержащий количество созданных и обновленных каталогов, а также их идентификаторы.

```json
{
  created: {
    count: number;
    id: number[] | string[];
  };
  updated: {
    count: number;
    id: number[] | string[];
  };
}
```

### Импорт учебных материалов

`GET api/widget/imports/materials/`

*Входные данные:* Отсутствуют

*Функционал:*

Работа метода разделена на несколько этапов:

1. Метод инициирует GET-запрос к URL `materials/import`, ожидая получить массив данных о материалах в формате, соответствующем типу `OldMaterial`:

```json
{
  id: number;
  createdAt?: string;
  updatedAt: string;
  name?: string;
  status: ACTIVE | ARCHIVE;
  url?: string;
  taskType?: CONTROl | TRAINING | control | home;
  description?: string;
  catalog: string;
  documents: OldDocument[]; // Нужно ли здесь расписывать все эти интерфейсы?
  textbook: OldTextbook;
  lessonMaterial: OldLessonMaterial;
}
```

1. На основе идентификаторов, извлеченных из полученных данных, метод использует `getExistingById()` для проверки, какие материалы уже существуют в базе данных.
3. Метод обращается к сервису `importCatalogsService`, вызывая `getData()`, чтобы получить массив каталогов. Эти каталоги будут использоваться для сопоставления с материалами.
4. Метод применяет `getForCreate()` для определения материалов, которые необходимо создать, и `getForUpdate()` для выявления материалов, которые требуют обновления.
5. Полученные массивы `creatingMaterials` и `updatingMaterials` объединяются в один массив `materialsToSave`, который будет использоваться для последующего сохранения в базе данных.
6. Метод подсчитывает количество материалов, которые будут созданы и обновлены, фильтруя материалы с пустыми идентификаторами.
7. Если массив `materialsToSave` содержит материалы, метод выполняет их сохранение в базе данных с помощью `materialRepository.save()`. Перед началом и по завершении операции в лог выводится сообщение с количеством создаваемых и обновляемых материалов.

*Выходные данные:* Status: `200 OK`

Возвращает объект, содержащий количество созданных и обновленных учебных материалов, а также их идентификаторы.

```json
{
  created: {
    count: number;
    id: number[] | string[];
  };
  updated: {
    count: number;
    id: number[] | string[];
  };
}
```

### Импорт тестов

`GET api/widget/imports/tests/`

*Входные данные:*

- Query параметры `ImportTestsDto`:

| Параметр | Тип данных                                                                                                                                                   | Валидация    | Описание  |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------ | --------- |
| type     | ONE \| CONFROMITY \| SEVERAL \| SHORT \| SEQUENCE \| SELECT_PICTURE \| DND_WORD \| TRUE_FALSE \| NUMBER \|<br>SELECT \| DND_OBJECT \| OMISSIONS \|<br>LIKERT | Обязательный | Тип теста |
| limit    | number                                                                                                                                                       | Опциональный |           |
| offset   | number                                                                                                                                                       | Опциональный |           |

*Функционал:*

Работа метода организована в несколько последовательных этапов:

1. Метод выполняет HTTP GET-запрос к URL `materials/tests/import`, передавая параметры из `ImportTestsDto`. Ожидается получение массива данных о старых тестах в формате `OldTest`.
2. Извлекаются идентификаторы старых тестов из полученных данных. Метод использует `getExistingById()` для проверки, какие из этих тестов уже существуют в базе данных.
3. Метод обращается к сервису `importCatalogsService`, вызывая `getData()`, чтобы получить массив каталогов. Эти каталоги будут использоваться для сопоставления с тестами.
4. Метод вызывает `getExistingOptionsId()`, чтобы получить идентификаторы существующих опций тестов, которые могут быть использованы при создании новых тестов.
5. Метод применяет `getForCreate()` для выявления тестов, которые необходимо создать, и `getForUpdate()` для определения тестов, требующих обновления.
6. Полученные массивы `creatingMaterials` и `updatingMaterials` объединяются в один массив `materialsForSave`, который будет использоваться для последующего сохранения в базе данных.
7. Метод подсчитывает количество тестов, которые будут созданы и обновлены, фильтруя тесты с пустыми идентификаторами.
8. Если массив `materialsForSave` содержит тесты, метод выполняет их сохранение в базе данных с помощью `materialRepository.save()`. Перед началом и по завершении операции в лог выводится сообщение с количеством создаваемых и обновляемых тестов.

*Выходные данные:* Status: `200 OK`

Возвращает объект, содержащий количество созданных и обновленных тестов, а также их идентификаторы.

```json
{
  created: {
    count: number;
    id: number[] | string[];
  };
  updated: {
    count: number;
    id: number[] | string[];
  };
}
```

### Импорт предметов

`GET api/widget/imports/subjects/`

*Входные данные:*

- Параметры

*Функционал:*

1. Метод инициирует GET-запрос к URL `things/import`, ожидая получить массив данных о предметах в формате, соответствующем типу `OldSubject`.
2. На основе идентификаторов, извлеченных из полученных данных, метод вызывает `getExistingById()`, чтобы определить, какие предметы уже существуют в базе данных.
3. Определение предметов для создания и обновления:
	1. Метод использует `getForCreate()`, чтобы выявить предметы, которые необходимо создать.
	2. Затем он применяет `getForUpdate()`, чтобы определить предметы, которые требуют обновления.
4. Полученные массивы `creatingSubjects` и `updatingSubjects` объединяются в один массив `subjectsForSave`, который будет использоваться для последующего сохранения в базе данных.
5. Метод подсчитывает количество предметов, которые будут созданы и обновлены, фильтруя предметы с пустыми идентификаторами.
6. Если массив `subjectsForSave` содержит предметы, метод выполняет их сохранение в базе данных с помощью `subjectRepository.save()`. Перед началом и по завершении операции в лог выводится сообщение с количеством создаваемых и обновляемых предметов.

*Выходные данные:* Status: `200 OK`

Возвращает объект, содержащий количество созданных и обновленных предметов, а также их идентификаторы.

```json
{
  created: {
    count: number;
    id: number[] | string[];
  };
  updated: {
    count: number;
    id: number[] | string[];
  };
}
```

### Импорт программ

`GET api/widget/imports/programs/`

*Входные данные:* Отсутствуют

*Функционал:*

1. Метод инициирует асинхронный GET-запрос к внешнему API по URL `programs/import`, ожидая получить массив данных о старых программах в формате `OldProgram`.
2. Из полученных данных извлекаются идентификаторы старых программ. Эти идентификаторы используются для вызова метода `getExistingById()`, который проверяет, какие из программ уже существуют в базе данных.
3. Метод обращается к сервису `importMaterialsService`, вызывая `getExistingById()`, чтобы получить массив существующих материалов, которые могут быть связаны с программами.
4. Метод также вызывает `importCatalogsService.getData()`, чтобы получить массив каталогов, которые будут использоваться для сопоставления с программами.
5. Метод применяет `getForCreate()` для выявления программ, которые необходимо создать, и `getForUpdate()` для определения программ, которые требуют обновления.
6. Полученные массивы `creatingPrograms` и `updatingPrograms` объединяются в один массив `programsToSave`, который будет использоваться для последующего сохранения в базе данных.
7. Метод подсчитывает количество программ, которые будут созданы и обновлены, фильтруя программы с пустыми идентификаторами.
8. Если массив `programsToSave` содержит программы, метод выполняет их сохранение в базе данных с помощью `programRepository.save()`. Перед началом и по завершении операции в лог выводится сообщение с количеством создаваемых и обновляемых программ.

*Выходные данные:* Status: `200 OK`

Возвращает объект, содержащий количество созданных и обновленных программ, а также их идентификаторы.

### Импорт разделов

`GET api/widget/imports/sections/`

*Входные данные:* Отсутствуют

*Функционал:*

1. Метод инициирует GET-запрос к URL `lessons/sections/import`, ожидая получить массив данных о секциях в формате, соответствующем типу `OldSection`. Это позволяет получить актуальную информацию о секциях, которые необходимо импортировать.
2. На основе полученных данных метод вызывает `getExistingSubjectByIds()`, чтобы извлечь идентификаторы предметов (thingId) из секций и проверить, какие из них уже существуют в базе данных.
3. Метод использует `getExistingById()`, чтобы определить, какие секции уже присутствуют в базе данных, используя идентификаторы, извлеченные из данных. Это позволяет избежать дублирования при импорте.
4. Метод применяет `getForCreate()` для выявления секций, которые необходимо создать, и `getForUpdate()` для определения секций, которые требуют обновления. Это обеспечивает правильное распределение секций по операциям.
5. Полученные массивы `creatingSections` и `updatingSections` объединяются в один массив `sectionsToSave`, который будет использоваться для последующего сохранения в базе данных. Это упрощает процесс сохранения, так как все секции, подлежащие изменению, находятся в одном месте.
6. Метод подсчитывает количество секций, которые будут созданы и обновлены, фильтруя секции с пустыми идентификаторами. Это позволяет получить статистику по операциям импорта.
7. Если массив `sectionsToSave` содержит секции, метод выполняет их сохранение в базе данных с помощью `lessonSectionRepository.save()`. Перед началом и по завершении операции в лог выводится сообщение с количеством создаваемых и обновляемых секций, что помогает отслеживать процесс импорта.

*Выходные данные:* Status: `200 OK`

Возвращает объект, содержащий количество созданных и обновленных секций, а также их идентификаторы.